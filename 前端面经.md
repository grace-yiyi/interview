---
title: 前端面经
date: 2020-7-30
tags:
 - 前端面经
categories:
 -  category1
---

## html

html

## css

css

## js

js

## vue

vue

## react

react

## node.js

### 1.NodeJs特点

- 非阻塞式的异步I/O
  - Node是一个单线程的语言，采用事件驱动和异步回调的机制。在执行代码的时候，主线程从上往下依次执行，遇到有需要回调的地方，就将此处加入到事件队列中，然后主线程继续往下走，直到运行结束以后，才去执行事件队列中的回调
  - node去执行事件队列中的事件时，如果遇到回调，依然是按照顺序添加进入事件队列，主线程一次往下执行，遇到回调就添加，直至执行完毕。
  - node是一个单线程多进程的。node进程创建一个循环，每个循环就是一个周期，在循环中会从事件队列里查看是否有事件需要处理，如果有就去除事件并执行相关的函数。对于阻塞事件的处理在幕后使用线程池来确保工作的运行，而不占用主循环流程
- 事件轮询
  - Nodejs 接收到的事件会放到事件队列中，而不是立即执行它，当 NodeJS 当前代码执行完后他会检查事件队列中是否有事件，如果有，他会取出来依次执行
- 单线程
  - Node.js 不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞 I/O、事件驱动机制，让 Node.js 程序宏观上也是并行的
  - 优点：不会死锁、不用像多线程那样处处在意同步问题、没有线程切换带来的性能上的开销
  - 缺点：多核 CPU 需单独开子线程、错误会使得整个应用退出、大量计算会占用 CPU 从而无法调用异步 I/O
- 擅长 I/O 密集型
  - 主要体现在 Node 利用事件轮询的方式处理事件，而不是单开一个线程来为每一个请求服务
- 不擅长 CPU 密集型业务
  - 由于 Node 单线程，如果长时间运行计算将导致 CPU 不能释放，使得后续 I/O 无法发起。（解决办法是分解大型运算为多个小任务，不阻塞 I/O 发起）

### 2.global对象

与在浏览器端不同，浏览器端将希望全局访问的对象挂到 window 上，而 nodejs 则将希望全局访问的对象挂到 global 对象上

- commonJS
- Buffer、process、console
- timer定时器相关



**setImmediate()、setTimeout(fn, 0) 与 process.nextTick()**

两个都是传入一个回调函数，当同步事件执行完之后马上执行。

执行顺序依次是：

- process.nextTick()
  - 将回调函数加入到 当前执行栈的尾部，任务队列之前
- setTimeout(fn, 0)
  - 回调函数加入到 任务队列尾部。即使是 0，也会又 4ms 的延时
- setImmediate()
  - 将回调函数插入到任务队列的最末尾，也不会造成阻塞，但不妨碍其他的异步事件

```javascript
setImmediate(() => {
  console.log("setImmediate");
});

setTimeout(() => {
  console.log("setImmediate");
}, 0);

process.nextTick(() => {
  console.log("next");
});
```

### 3.异步I/O

**为什么要异步I/O**

- 用户体验，快!

  使用阻塞式加载两个资源时间为 M + N

  使用异步 I/O 加载两个资源时间为： max(M, N)

- 资源分配

  假设有一堆不相关的任务需要完成，主流有两种

  单线程串行依次执行

  多线程并行执行

  多线程的代价在于创建线程和执行线程上下文切换的开销较大。在复杂业务中，多线程编程经常面临锁、状态同步等问题，这是多线程的主要诟病。

  单线程顺序执行比较符合思考顺序，而且易于表达。但串行执行